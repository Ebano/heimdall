<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Index on Heimdall</title><link>https://dadrus.github.io/</link><description>Recent content in Index on Heimdall</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 05 Jun 2022 20:03:18 +0200</lastBuildDate><atom:link href="https://dadrus.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Welcome</title><link>https://dadrus.github.io/docs/welcome/</link><pubDate>Fri, 10 Jun 2022 17:30:17 +0200</pubDate><guid>https://dadrus.github.io/docs/welcome/</guid><description>Background The Typical deployment scenario diagram sketches how authentication and authorization is handled in most of today’s applications.
Figure 1. Typical deployment scenario On the one hand it allows the backend service to fully control the corresponding security requirements. On the other hand it has some limitations:
It works as long as there is just one authentication system.
When there are multiple backend services, which is typically the case in modern architectures, it requires each backend service to repetitively implement security related capabilities in its code, and related to this</description></item><item><title>Concepts</title><link>https://dadrus.github.io/docs/getting_started/concepts/</link><pubDate>Sat, 25 Jun 2022 14:29:17 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/concepts/</guid><description>Everything you need to know.
Pipeline As described in the Welcome section and also shown in the diagram below, Heimdall authenticates and authorizes incoming HTTP requests, rejecting unauthenticated or unauthorized ones, as well as enriches the valid requests with further information and transforms resulting subject information to a format, required by the upstream services. This is done in upstream service specific rules, which define the required individual pipelines.
Figure 1.</description></item><item><title>Quickstart</title><link>https://dadrus.github.io/docs/getting_started/quickstart/</link><pubDate>Wed, 08 Jun 2022 20:43:27 +0200</pubDate><guid>https://dadrus.github.io/docs/getting_started/quickstart/</guid><description>This document describes a very simple use case.
Prerequisites git
The Go programming language &amp;gt;= 1.18.1
Docker if you want to build a docker container (you don’t need Golang then)
Download Retrieve the latest copy of heimdall source code by cloning the git repository
$ git clone git@github.com:dadrus/heimdall.git Build with go Build using a single line with go build
$ go build -trimpath -ldflags=&amp;#34;-buildid= -w -s -X heimdall/cmd.Version=my-custom-build&amp;#34; The flags are set by intention.</description></item><item><title>CLI</title><link>https://dadrus.github.io/docs/operations/cli/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/operations/cli/</guid><description>Heimdall’s Command Line Interface
General heimdall [command] [flags] [arguments] Use heimdall help to get overview about available commands, respectively heimdall [command] help for help on any command.
Flag’s usage:
# set flag_argument to flag(s) heimdall [--flag=flag_argument] [-f [flag_argument]] E.g.
heimdall validate config -c config.yaml Commands completion
Generates the autocompletion script for the specified shell.
health
Calls heimdall’s healthcheck endpoint to verify the status of the deployment.
serve
Starts heimdall in the decision api, or the reverse proxy mode.</description></item><item><title>Traefik Proxy Integration</title><link>https://dadrus.github.io/docs/guides/traefik/</link><pubDate>Thu, 09 Jun 2022 18:59:49 +0200</pubDate><guid>https://dadrus.github.io/docs/guides/traefik/</guid><description>Traefik Proxy is a modern HTTP proxy and load balancer for microservices, heimdall can be integrated with via the ForwardAuth Middleware by making use of the Decision API. In such setup, traefik delegates authentication and authorization to heimdall. If heimdall answers with a 2XX code, traefik grants access and forwards the original request to the upstream service. Otherwise, the response from heimdall is returned to the client.
To achieve this,</description></item><item><title>Decision API</title><link>https://dadrus.github.io/docs/configuration/services/decision_api/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/decision_api/</guid><description>Decision API is one of the operating modes supported by Heimdall, used if you start Heimdall with heimdall serve api. By default, Heimdall listens on 0.0.0.0:4456/decisions endpoint for incoming requests in this mode of operation and also configures useful default timeouts. No other options are configured. You can, and should however adjust the configuration for your needs.
Configuration The configuration for the Decision API can be adjusted in the api property, which lives in the serve property of heimdall’s configuration and supports the following properties.</description></item><item><title>Proxy</title><link>https://dadrus.github.io/docs/configuration/services/proxy/</link><pubDate>Thu, 09 Jun 2022 18:55:45 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/proxy/</guid><description>Not implemented yet. Will however support the same configuration options as Decision APi</description></item><item><title>Common Configuration Options</title><link>https://dadrus.github.io/docs/configuration/services/configuration_types/</link><pubDate>Thu, 09 Jun 2022 18:55:36 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/services/configuration_types/</guid><description>Timeout Following configuration options are supported:
read: Duration (optional)
The amount of time allowed to read the full request including body. Defaults to 5 seconds.
write: Duration (optional)
The maximum duration before timing out writes of the response. Defaults to 10 seconds.
idle: Duration (optional)
The maximum amount of time to wait for the next request when keep-alive is enabled. If ìdle is 0, the value of read timeout is used.</description></item><item><title>Logging</title><link>https://dadrus.github.io/docs/configuration/observability/logging/</link><pubDate>Thu, 09 Jun 2022 18:56:07 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/logging/</guid><description>Heimdall logs concern everything that happens to Heimdall itself (startup, configuration, events, shutdown, and so on). Logs are written to stdout by default in text format.
Configuration Logging configuration can be adjusted in the log property of heimdall’s configuration and supports following properties.
format: string (optional)
With text and gelf being the available formats. text is the default format. And gelf defines a a JSON format more or less adhering to GELF.</description></item><item><title>Metrics</title><link>https://dadrus.github.io/docs/configuration/observability/metrics/</link><pubDate>Thu, 09 Jun 2022 22:16:45 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/metrics/</guid><description>As of today, heimdall only supports Prometheus as metrics backend, which is also enabled by default by exposing available metrics on 0.0.0.0:9000/metrics endpoint.
Prometheus Configuration for Prometheus can be adjusted in the prometheus property, which lives in the metrics property of heimdall’s configuration and supports following properties.
host: string (optional)
By making use of this property, you can specify the TCP/IP address on which heimdall should listen for connections from client applications.</description></item><item><title>Tracing</title><link>https://dadrus.github.io/docs/configuration/observability/tracing/</link><pubDate>Thu, 09 Jun 2022 18:56:12 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/observability/tracing/</guid><description>Heimdall allows visualization of call flows in your infrastructure. It does this by using OpenTracing, an open standard designed for distributed tracing.
Following tracing backends are currently supported:
Jaeger
Instana
Configuration By default, tracing is disabled, but can be configured in the tracing property of heimdall’s configuration and supports following properties.
provider: string (mandatory)
By making use of this property, you can configure heimdall to enable tracing and use one of the supported tracing providers:</description></item><item><title>Pipeline Overview</title><link>https://dadrus.github.io/docs/configuration/pipeline/pipeline_overview/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/pipeline_overview/</guid><description>This section explains the available pipeline handler and mechanisms in detail. Before diving onto the details of these, we recommend to make yourself familiar with the principal architecture and components.
The general pipeline handlers are:
Authenticators inspect HTTP requests, like the presence of a specific cookie, which represents the authentication object of the subject with the service and execute logic required to verify the authentication status and obtain information about that subject.</description></item><item><title>Authenticators</title><link>https://dadrus.github.io/docs/configuration/pipeline/authenticators/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/authenticators/</guid><description>Authenticators inspect HTTP requests, like the presence of a specific cookie, which represents the authentication object of the subject with the service and execute logic required to verify the authentication status and obtain information about that subject. A subject, could be a user who tries to use particular functionality of the upstream service, a machine (if you have machine-2-machine interaction), or something different. Authenticators ensure the subject has already been authenticated and the information available about it is valid.</description></item><item><title>Authorizers</title><link>https://dadrus.github.io/docs/configuration/pipeline/authorizers/</link><pubDate>Thu, 09 Jun 2022 18:57:03 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/authorizers/</guid><description>Authorizers ensure that the subject obtained via an authenticator step has the required permissions to submit the given HTTP request and thus to execute the corresponding logic in the upstream service. E.g. a specific endpoint of the upstream service might only be accessible to a &amp;#34;user&amp;#34; from the &amp;#34;admin&amp;#34; group, or to an HTTP request if a specific HTTP header is set.
The following section describes the available authorizer types in more detail.</description></item><item><title>Hydrators</title><link>https://dadrus.github.io/docs/configuration/pipeline/hydrators/</link><pubDate>Thu, 09 Jun 2022 18:57:10 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/hydrators/</guid><description>Hydrators enrich the information about the subject obtained in the authenticator step with further information, required by either the endpoint of the upstream service itself or an authorizer step. This can be handy if the actual authentication system doesn’t have all information about the subject (which is usually the case in microservice architectures), or if dynamic information about the subject, like the current location based on the IP address, is required.</description></item><item><title>Mutators</title><link>https://dadrus.github.io/docs/configuration/pipeline/mutators/</link><pubDate>Thu, 09 Jun 2022 18:57:16 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/mutators/</guid><description>Mutators finalize the successful execution of the pipeline and transform the available information about the subject into a format expected, respectively required by the upstream service. This ranges from adding a query parameter, to a structured JWT in a specific header.
The following section describes the available mutator types in more detail.
Mutator Types Noop As the name implies, this mutator does nothing. As mutators are the last step in Heimdall’s pipeline and transform available subject information into an object required by the upstream service, the usage of this mutator makes only sense in combination with the Noop Authenticator for public APIs.</description></item><item><title>Error Handlers</title><link>https://dadrus.github.io/docs/configuration/pipeline/error_handlers/</link><pubDate>Thu, 09 Jun 2022 18:57:29 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/error_handlers/</guid><description>Error Handlers are responsible for execution of logic if any of the handlers authenticators, authorizers, hydrators or mutators fail. The error handlers range from a simple error response to the client which sent the request to sophisticated handlers supporting complex logic and redirects.
The following section describes the available error handler types in more detail.
Error Handler Types Default This error handler is always there and is executed if no other error handler is responsible for the handling of an error.</description></item><item><title>Configuration Types</title><link>https://dadrus.github.io/docs/configuration/pipeline/configuration_types/</link><pubDate>Thu, 09 Jun 2022 18:56:56 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/pipeline/configuration_types/</guid><description>Assertions This type enables configuration of required token and claim assertions. Depending on the object type (JWT or introspection response), the assertions apply to different parts of such objects.
scopes: Scopes Matcher (optional)
Required scopes given to the client.
audience: string array (optional)
Required entries in the aud claim. Both cases, either as whitespace separated string, or a JSON array are considered.
issuers: string array (mandatory)
Issuers to trust. At least one issuer must be configured.</description></item><item><title>Rules Overview</title><link>https://dadrus.github.io/docs/configuration/rules/rules_overview/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/rules_overview/</guid><description>This section explains how rules can be defined and used in detail. Before diving onto this topic, we recommend to make yourself familiar with the principal architecture and components.
Core aspects of Heimdall are rules. These let Heimdall execute logic required by your upstream service to authenticate, authorize the incoming requests, enrich the information about the subject and mutate it according to the needs of the upstream service. However, to be able to define even a single rule, you must configure pipeline handlers, which you can then reference according to your, respectively the needs of your particular upstream service.</description></item><item><title>Default Rule</title><link>https://dadrus.github.io/docs/configuration/rules/default_rule/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/default_rule/</guid><description>Heimdall lets you not only define upstream service specific rules, it does also support a definition of an optional default rule, which, if defined, kicks in, if no other rule matches. This way you can ensure secure defaults by simultaneously reducing the amount of work while defining upstream service API specific rules. That is, an upstream service API specific rule can reuse definitions from the default rule.
The configuration of the default rule can be done by making use of the default property and configuring the following options.</description></item><item><title>Rule Definition</title><link>https://dadrus.github.io/docs/configuration/rules/rule_configuration/</link><pubDate>Thu, 09 Jun 2022 22:13:32 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/rule_configuration/</guid><description>Rules are the heart of heimdall. These allow execution of arbitrary logic, required by your upstream service. This section describes everything related to the configuration of a particular rule and how can these be combined to rule sets, which can then be loaded by a rule provider.
Rule Configuration A single rule consists of the following properties:
id: string (mandatory)
The unique identifier of a rule. It must be unique across all rules.</description></item><item><title>Rule Providers</title><link>https://dadrus.github.io/docs/configuration/rules/providers/</link><pubDate>Thu, 09 Jun 2022 22:13:54 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/rules/providers/</guid><description>Providers define the sources to load the rule sets from. These make Heimdall’s behavior dynamic. All providers, you want to enable for a Heimdall instance must be configured by within the providers section of Heimdall’s rules configuration.
Supported providers, including the corresponding configuration options are described below
Filesystem The filesystem provider allows loading of rule sets from a file system. The configuration of this provider goes into the file property.</description></item><item><title>Static Configuration</title><link>https://dadrus.github.io/docs/configuration/reference/configuration/</link><pubDate>Thu, 09 Jun 2022 18:57:50 +0200</pubDate><guid>https://dadrus.github.io/docs/configuration/reference/configuration/</guid><description>Below you can find possible contents (not exhaustive) for Heimdall’s config.yaml file. Head over to configuration documentation to get detailed explanation.
serve: api: host: 127.0.0.1 port: 4468 verbose_errors: true timeout: read: 2s write: 5s idle: 2m cors: allowed_origins: - example.org allowed_methods: - GET - POST allowed_headers: - Authorization exposed_headers: - X-My-Header allow_credentials: true max_age: 1m tls: key: /path/to/key/file.pem cert: /path/to/cert/file.pem trusted_proxies: - 192.168.1.0/24 proxy: host: 127.0.0.1 port: 4469 verbose_errors: false timeout: read: 2s write: 5s idle: 2m cors: allowed_origins: - example.</description></item></channel></rss>