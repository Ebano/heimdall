---
title: "Catalogue"
date: 2024-01-11T15:01:21+02:00
draft: false
weight: 51
menu:
  docs:
    weight: 1
    parent: "Mechanisms"
---

As described in link:{{< relref "/docs/getting_started/mechanisms.adoc" >}}[Getting Started / Mechanisms] section, mechanisms must be defined and configured before these can be used in rules.

== Catalogue Configuration

The corresponding mechanisms catalogue resides under the `mechanisms` property of heimdall static configuration and is organized based on mechanism categories as also shown in the snippet below.

[source, yaml]
----
mechanisms:
  authenticators:
    <list of authenticator definitions>
  authorizers:
    <list of authorizer definitions>
  contextualizers:
    <list of contextualizer definitions>
  finalizers:
    <list of finalizer definitions>
  error_handlers:
    <list of error handler definitions>
----

== General Mechanism Configuration

Each mechanism definition entry in the catalogue contains the following properties:

* `id` - A mandatory unique identifier of the mechanism. Identifiers are used to reference the required mechanism within a rule, respectively its pipelines. You can choose whatever identifier, you want. It is just a name. It must however be unique across all defined mechanisms of a particular mechanism category (like authenticator, authorizer, etc.).
* `type` - The mandatory specific type of the mechanism in the given category.
* `config` - The mechanism's specific configuration if required by the type.

Every mechanism type can be configured as many times as needed. However, for those, which don't have a configuration, it doesn't really make sense, as all of them would behave the same way.

For example, your authenticator definitions could look like this (imaginary types are used):

[source, yaml]
----
mechanisms:
  authenticators:
  - id: foo
    type: bar
  - id: baz
    type: bla
    config:
      bla: bar
  - id: zab
    type: bar
  - id: oof
    type: bla
    config:
      bar: bla
----

The above snippet configures

* two instances of an imaginary authenticator of a type `bar`, made available for usage in rules via ids `foo` and `zab`, as well as
* two instances of an imaginary authenticator of a type `bla`, made available for usage in rule via ids `baz` and `oof`.

The `baz` and `oof` authenticators are different, as they are configured differently, but `foo` and `zab` authenticators do not have any configuration. So, they behave the same way and there is actually no need to define two instances of them.

== Mechanisms Catalogue Example

Here is an example which defines a mechanism catalogue using some of the available types:

[source, yaml]
----
mechanisms:
  authenticators:
  - id: anon_authn
    type: anonymous
  - id: opaque_auth_token_authn
    type: oauth2_introspection
    config:
      introspection_endpoint:
        url: http://hydra:4445/oauth2/introspect
    assertions:
      issuers:
        - http://127.0.0.1:4444/
  authorizers:
  - id: deny_all_authz
    type: deny
  - id: local_authz
    type: cel
    config:
      expressions:
        - expression:
            "manager" in Subject.Attributes.groups
          message: user is not in the expected group
  contextualizers:
  - id: group_manager
    type: generic
    config:
      endpoint:
        url: http://group-manager.local/groups
        method: GET
      forward_headers:
        - Authorization
      cache_ttl: 1m
  finalizers:
  - id: jwt_finalizer
    type: jwt
    config:
      ttl: 5m
      claims: |
          {
            {{ $user_name := .Subject.Attributes.identity.user_name -}}
            "email": {{ quote .Subject.Attributes.identity.email }},
            "email_verified": {{ .Subject.Attributes.identity.email_verified }},
            {{ if $user_name -}}
            "name": {{ quote $user_name }}
            {{ else -}}
            "name": {{ quote $email }}
            {{ end -}}
          }
  error_handlers:
  - id: default
    type: default
  - id: authenticate_with_kratos
    if: |
      type(Error) in [authentication_error, authorization_error] &&
      Request.Header("Accept").contains("text/html")
    type: redirect
    config:
      to: http://127.0.0.1:4433/self-service/login/browser?return_to={{ .Request.URL | urlenc }}
----
